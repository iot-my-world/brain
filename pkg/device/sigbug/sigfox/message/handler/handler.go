package handler

import (
	"encoding/binary"
	brainException "github.com/iot-my-world/brain/internal/exception"
	"github.com/iot-my-world/brain/internal/log"
	"github.com/iot-my-world/brain/pkg/device/sigbug"
	sigbugAdministrator "github.com/iot-my-world/brain/pkg/device/sigbug/administrator"
	"github.com/iot-my-world/brain/pkg/device/sigbug/reading/gps"
	sigbugGPSReadingAdministrator "github.com/iot-my-world/brain/pkg/device/sigbug/reading/gps/administrator"
	sigbugRecordHandler "github.com/iot-my-world/brain/pkg/device/sigbug/recordHandler"
	"github.com/iot-my-world/brain/pkg/device/sigbug/sigfox/message"
	sigfoxBackendDataDataCallbackMessageHandlerException "github.com/iot-my-world/brain/pkg/device/sigbug/sigfox/message/handler/exception"
	"github.com/iot-my-world/brain/pkg/search/identifier/id"
	sigfoxBackendDataDataCallbackMessage "github.com/iot-my-world/brain/pkg/sigfox/backend/callback/data/message"
	sigfoxBackendDataDataCallbackMessageHandler "github.com/iot-my-world/brain/pkg/sigfox/backend/callback/data/message/handler"
	"math"
)

type handler struct {
	sigbugRecordHandler           sigbugRecordHandler.RecordHandler
	sigbugAdministrator           sigbugAdministrator.Administrator
	sigbugGPSReadingAdministrator sigbugGPSReadingAdministrator.Administrator
}

func New(
	sigbugRecordHandler sigbugRecordHandler.RecordHandler,
	sigbugAdministrator sigbugAdministrator.Administrator,
	sigbugGPSReadingAdministrator sigbugGPSReadingAdministrator.Administrator,
) sigfoxBackendDataDataCallbackMessageHandler.Handler {
	return &handler{
		sigbugRecordHandler:           sigbugRecordHandler,
		sigbugAdministrator:           sigbugAdministrator,
		sigbugGPSReadingAdministrator: sigbugGPSReadingAdministrator,
	}
}

func (h *handler) WantMessage(dataMessage sigfoxBackendDataDataCallbackMessage.Message) bool {
	if len(dataMessage.Data) == 0 {
		return false
	}

	switch dataMessage.Data[0] {
	case message.CouldNotGetGPSFixMessageType:
		return true

	case message.GPSReading:
		if len(dataMessage.Data) == 9 {
			return true
		}
	}

	return false
}

func (h *handler) ValidateHandleRequest(request *sigfoxBackendDataDataCallbackMessageHandler.HandleRequest) error {
	reasonsInvalid := make([]string, 0)

	if request.Claims == nil {
		reasonsInvalid = append(reasonsInvalid, "claims are nil")
	}

	if len(reasonsInvalid) > 0 {
		return brainException.RequestInvalid{Reasons: reasonsInvalid}
	}
	return nil
}

func (h *handler) Handle(request *sigfoxBackendDataDataCallbackMessageHandler.HandleRequest) error {
	if err := h.ValidateHandleRequest(request); err != nil {
		log.Error(err.Error())
		return err
	}

	// try and retrieve the device which this data message was generated by
	retrieveSigbugResponse, err := h.sigbugRecordHandler.Retrieve(&sigbugRecordHandler.RetrieveRequest{
		Claims: request.Claims,
		Identifier: sigbug.Identifier{
			DeviceId: request.DataMessage.DeviceId,
		},
	})
	if err != nil {
		err = sigfoxBackendDataDataCallbackMessageHandlerException.HandleGPSMessage{Reasons: []string{"retrieve sigbug device", err.Error()}}
		log.Error(err)
		return err
	}

	// update last message timestamp on sigbug
	if _, err := h.sigbugAdministrator.LastMessageUpdate(&sigbugAdministrator.LastMessageUpdateRequest{
		Claims: request.Claims,
		Identifier: sigbug.Identifier{
			DeviceId: request.DataMessage.DeviceId,
		},
		Message: request.DataMessage,
	}); err != nil {
		err = sigfoxBackendDataDataCallbackMessageHandlerException.HandleGPSMessage{Reasons: []string{
			"updating last message on device",
			err.Error(),
		}}
		log.Error(err)
		return err
	}

	// pass message to individual handler types
	switch request.DataMessage.Data[0] {
	case message.CouldNotGetGPSFixMessageType:
		return h.handleCouldNotGetFixMessage(request, &retrieveSigbugResponse.Sigbug)

	case message.GPSReading:
		return h.handleGPSMessage(request, &retrieveSigbugResponse.Sigbug)
	}

	return nil
}

//
// Individual message type handlers
//
func (h *handler) handleCouldNotGetFixMessage(request *sigfoxBackendDataDataCallbackMessageHandler.HandleRequest, sigbugDevice *sigbug.Sigbug) error {
	log.Info("handle!")
	return nil
}

func (h *handler) handleGPSMessage(request *sigfoxBackendDataDataCallbackMessageHandler.HandleRequest, sigbugDevice *sigbug.Sigbug) error {
	if len(request.DataMessage.Data) != 9 {
		return sigfoxBackendDataDataCallbackMessageHandlerException.HandleGPSMessage{Reasons: []string{"message data not long enough"}}
	}

	// try and retrieve the device which this data message was generated by
	retrieveSigbugResponse, err := h.sigbugRecordHandler.Retrieve(&sigbugRecordHandler.RetrieveRequest{
		Claims: request.Claims,
		Identifier: sigbug.Identifier{
			DeviceId: request.DataMessage.DeviceId,
		},
	})
	if err != nil {
		err = sigfoxBackendDataDataCallbackMessageHandlerException.HandleGPSMessage{Reasons: []string{"retrieve sigbug device", err.Error()}}
		log.Error(err)
		return err
	}

	// create gps reading
	if _, err := h.sigbugGPSReadingAdministrator.Create(&sigbugGPSReadingAdministrator.CreateRequest{
		Claims: request.Claims,
		Reading: gps.Reading{
			DeviceId: id.Identifier{
				Id: retrieveSigbugResponse.Sigbug.Id,
			},
			OwnerPartyType:    retrieveSigbugResponse.Sigbug.OwnerPartyType,
			OwnerId:           retrieveSigbugResponse.Sigbug.OwnerId,
			AssignedPartyType: retrieveSigbugResponse.Sigbug.AssignedPartyType,
			AssignedId:        retrieveSigbugResponse.Sigbug.AssignedId,
			TimeStamp:         request.DataMessage.Timestamp,
			Latitude:          math.Float32frombits(binary.LittleEndian.Uint32(request.DataMessage.Data[1:5])),
			Longitude:         math.Float32frombits(binary.LittleEndian.Uint32(request.DataMessage.Data[5:])),
		},
	}); err != nil {
		err = sigfoxBackendDataDataCallbackMessageHandlerException.HandleGPSMessage{Reasons: []string{"create gps reading", err.Error()}}
		log.Error(err)
		return err
	}

	return nil
}
